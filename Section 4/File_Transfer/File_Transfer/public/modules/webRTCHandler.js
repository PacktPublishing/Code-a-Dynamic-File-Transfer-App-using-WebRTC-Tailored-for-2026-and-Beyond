// import modules
import * as uiUtils from "./uiUtils.js";
import * as constants from "./constants.js";
import * as state from "./state.js";
import * as ws from "./ws.js";

// Global WebRTC variables
let pc; // peer connection
let sendChannel; // data channel for file sender
let receiveChannel; // data channel for file receiver
const iceCandidatesReceivedBuffer = [];

// Configure ice servers
const WebRTCConfigurations = {
    iceServers: [
        {
            urls: [
                "stun:stun.l.google.com:19302",
                "stun:stun2.l.google.com:19302",
                "stun:stun3.l.google.com:19302",
                "stun:stun4.l.google.com:19302",
            ]
        }
    ]
};

export async function createAndSendOffer() {
    // step 1: createa a peer connection object. This is the main object used to manage the WebRTC connection in the user's browser.
    createPeerConnection();
    uiUtils.logToCustomConsole(`Created pc object`);
    
    // step 2: create a WebRTC data channel
    createDataChannel(true); // pass true because we know this is the "sender" of the file.
    uiUtils.logToCustomConsole(`Created data channel`);

    // step 3: create offer (we do this after we have created our data channel in step 2)
    const offer = await pc.createOffer(); // includes SDP info about the sender
    uiUtils.logToCustomConsole(`Created offer`);

    // step 4: add our details to the local descripton of our pc object
    await pc.setLocalDescription(offer);
    uiUtils.logToCustomConsole(`Local description set`);

    // step 5. Blast off ðŸš€ Finally, send your offer to the other peer
    // sending webrtc offer
    ws.sendOffer(offer);
    uiUtils.logToCustomConsole(`WebRTC offer sent`);
}; // end function: create and send WebRTC offer

// create local peer connection
function createPeerConnection() {

    pc = new RTCPeerConnection(WebRTCConfigurations);
    
    // ICE candidate event listener
    pc.onicecandidate = (event) => {
        uiUtils.logToCustomConsole(`Ice candidate generated by browser`, null, true, constants.myColors.blue);
        if(event.candidate) {
            console.log("ICE: ", event.candidate);
            // SEND ICE TO OTHER SIDE
            ws.sendIceCandidate(event.candidate);
        };
    };

    // Add an event listener for connection state changes
    pc.addEventListener('connectionstatechange', () => {
        console.log("connection state: ", pc.connectionState);
        if (pc.connectionState === 'connected') {
            uiUtils.logToCustomConsole(`WebRTC state changed: ${pc.connectionState}`, null, true, constants.myColors.green);
            uiUtils.DOM.fileUploadInput.disabled = true;
        };
    });

    // Add an event listener for signalling state change
    pc.addEventListener('signalingstatechange', () => {
        uiUtils.logToCustomConsole(`Signaling state changed: ${pc.signalingState}`, null, true, constants.myColors.orange);
    });

}; // *** END PEER CANDIDATE LOGIC

// create a data channel
function createDataChannel(isSender) {
    if (isSender) {
        // only need to create a data channel once, when a WebRTC offer is established
        sendChannel = pc.createDataChannel("file-transfer-channel");
        // add event listeners
        registerDataChannelEventListeners(sendChannel);
    } else {
        // if this else is executed, we are dealing with the receiver of the file (the WebRTC offeree)
        // the receiver needs to register a ondatachannel event listener
        // this will only fire once a valid webrtc connection has been established
        pc.ondatachannel = (e) => {
            receiveChannel = e.channel; // data channel for receiver
            registerDataChannelEventListeners(receiveChannel);
            uiUtils.logToCustomConsole("Succesfully registered ondatachannel listener on your pc object");
            
        }
    }
};

function registerDataChannelEventListeners(dataChannel) {
    dataChannel.addEventListener("error", (e) => {
        console.log("An error occured on the Data Channel: ", e);
    });
    dataChannel.addEventListener("close", (e) => {
        // will fire for all users that are listening on this data channel
        console.log("The 'close' event was fired on your data channel object");
        // TBC LATER
    });
    dataChannel.addEventListener("open", (e) => {
        // this will fire when webrtc connection is established. 
        dataChannel.maxMessageSize = pc.sctp.maxMessageSize;
        console.log("Data Channel has been opened. You are now ready to send/receive files over your Data Channel");
        console.log('PC object: ', pc);
        console.log('DataChannel object: ', dataChannel);
        // later add code to handle sending file logic 
        
    });


    // listen for incoming file
    if(receiveChannel) {
        dataChannel.addEventListener("message", (eventData) => {
            // RECEIVE FILE LOGIC .... TBC LATER
        });
    }
};

function closePeerConnection() {
    pc.close();
    uiUtils.logToCustomConsole('Your peer connection has been closed', constants.myColors.green);
};

export async function handleOffer(data) {
    // update state
    uiUtils.logToCustomConsole("ðŸ“„ WebRTC offer received");
    state.setOtherUserId(data.senderId);
    // // Step 1, create pc
    createPeerConnection();
    uiUtils.logToCustomConsole("Peer connection created");
    // // Step 2, add data channel
    createDataChannel(false);
    // // Step 3, set remote description with the offer
    pc.setRemoteDescription(data.offer); // set remote description to offer
    // check our ice buffer and if any ice exists in buffer, add it to the remote description
    addIceCandidatesInBuffer();
    uiUtils.logToCustomConsole("Remote description updated with the offer");
    // // Step 4, create answer
    const answer = await pc.createAnswer(); // This promise resolves to an RTCSessionDescription object that contains the SDP (Session Description Protocol) answer
    uiUtils.logToCustomConsole("Answer created");
    // // STEP 5, set local description
    await pc.setLocalDescription(answer); // This also returns a promise
    uiUtils.logToCustomConsole("Local description updated with the answer");
    // send answer back to signaling server, to relay to original sender
    ws.sendAnswer(answer);
    uiUtils.logToCustomConsole("Answer sent to the user sending the file");
};

export async function handleAnswer(data) {
    uiUtils.logToCustomConsole("Answer received");
    await pc.setRemoteDescription(data.answer);
    addIceCandidatesInBuffer();
    uiUtils.logToCustomConsole("Remote description updated with the answer");
};

// handle ice candidates received from the signaling server
export function handleIceCandidates(iceCandidate) {
    if(pc.remoteDescription) {
        try {
            pc.addIceCandidate(iceCandidate);
            uiUtils.logToCustomConsole("Remote ICE added", null, true, constants.myColors.blue);
        } catch (error) {
            console.log("Error trying to add an ice candidate to the pc object", error);
        }
    } else {
        iceCandidatesReceivedBuffer.push(iceCandidate);
        uiUtils.logToCustomConsole("Remote ICE added to a temp buffer");
    }
}

async function addIceCandidatesInBuffer() {
    for(const candidate of iceCandidatesReceivedBuffer) {
        await pc.addIceCandidate(candidate);
        uiUtils.logToCustomConsole('Remote ICE transferred from buffer to pc object');
    }
    iceCandidatesReceivedBuffer.splice(0, iceCandidatesReceivedBuffer.length); // reset buffer
}

