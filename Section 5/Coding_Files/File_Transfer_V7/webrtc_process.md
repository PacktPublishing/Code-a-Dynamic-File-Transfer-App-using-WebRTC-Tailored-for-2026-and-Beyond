# WebRTC Connection Setup To Send Files - Overview
*Skill Level:* Intermediate - Advanced

This document outlines the steps required to establish a WebRTC connection between two clients (lets call them SENDER and RECEIVER) using signaling via a Node.js WebSocket server. This is what we're doing in the course to send files. 

## Phase 1: üôç‚Äç‚ôÇÔ∏è SENDER Sets Up WebRTC and Sends Offer
- **Role**: You can refer to SENDER as the Initiator/Caller/Offeror. These steps involve the user and their browser preparing to establish a WebRTC connection. In our course project, this will be triggered when the user decides to "send" their file.

### 1. Configure STUN (or TURN if applicable) Servers
- **Note**: The `RTCPeerConnection` requires STUN servers for NAT traversal in real-world applications. You do this by specifing configuration options for your RTCPeerConnection.
- **Purpose**: ICE candidates will be needed to help SENDERS PC locate RECEIVERS PC.
- **Remember üí°**: An `ICE Candidate` is just a fancy word for a "possible route to a browser window".

### 2. Create RTCPeerConnection Object
- **Action**: SENDER creates an instance of `RTCPeerConnection` on their browser. This instance is necessary to generate the WebRTC offer that will be sent to the file RECEIVER via our signaling server. 
- **Details**: Not only do we create an instance of the `RTCPeerConnection' object, but we also need to register event listeners
- **Remember üí°**: The `RTCPeerConnection` manages the entire connection between SENDER and RECEIVER.

### 3. Define Data to Send/Receive
- **Action**: SENDER must determine what data it will allow to be sent and received (e.g., SENDER will call `getUserMedia()` if they want to send/receive video and audio for example). In our course project, we will use our peer connection to create a Data Channel by calling `pc.createDataChannel()`. We will then use this data channel to send our binary file bytes over the wire. 

### 4. Add Data to the RTCPeerConnection
- **Action**: SENDER adds the data type (a data channel in our case, but could also be a video stream and audio track) to its `RTCPeerConnection`.
- **Purpose**: This action associates SENDERS data with their `RTCPeerConnection`.

### 5. SENDER Creates an Offer
- **Action**: SENDER creates a WebRTC offer using its `RTCPeerConnection` that is using a data channel.
- **Details**:
  - The offer is an object of type `RTCSessionDescription`, which contains two parts:
    - **SDP**: Contains information about the data to be exchanged (here a simple data channel which will contain our binary file data).
    - **Type**: Designated as "offer" indicating that the SENDER of the file has initiated the WebRTC connection.

### 6. Set Local Description
- **Action**: The SENDERS offer is floating around in space. So SENDER assigns the generated offer to the `RTCPeerConnection` using the `setLocalDescription()` method.

### 7. Collect ICE Candidates 
- **Note**: When `setLocalDescription()` is executed, SENDERS browser will start to gather ICE candidates and will return them to SENDER, asynchronously. 
- **Action**: SENDER sends its ice candidates to the RECEIVER immediately. We will handle logic on the RECEIVER side to ensure that if their WebRTC object is not yet set up, they will hold them in a temp buffer. 

### 8. SENDER Sends the final completed "Offer" to Signaling Server
- **Action**: SENDER sends the offer to our WS signaling server. 
- **Details**:
  - Our signaling server will forward the WebRTC offer to RECEIVER.
  - The offer must be associated with SENDER.

### 9. SENDER Sends ICE Candidates to Signaling Server
- **Action**: Once ICE candidates become available, SENDER will send them to signaling server.
- **Details**:
  - The signaling server will relay these ICE candidates (routes to its PC) to the RECEIVER.
  - Each ICE candidate will be associated with SENDER.

## PHASE 2: üì∂üì∂üì∂ Signaling Server
Our WebSocket signaling server is now used to facilitate communication between both peers.
### 10. Signaling Server sends Offer to RECEIVER

## PHASE 3: üë®‚Äçü¶∞ RECEIVER sets up WebRTC and Sends Answer
- **Role**: You can refer to RECEIVER as the Calleee/Offeree.

### 11. RECEIVER Loads Webpage
- **Action**: RECEIVER needs a WebSocket connection with our signaling server. 

### 12. RECEIVER Receives Offer
- **Action**: RECEIVER receives the RTCSessionDescription (offer) pushed to it by our signaling server from the file SENDER.

### 13. Configure STUN Servers
- **Note**: RECEIVERS `RTCPeerConnection` also requires STUN servers for NAT traversal in real-world applications.
- **Purpose**: ICE candidates are generated by RECEIVER as they are needed to enable SENDER to locate RECEIVER.

### 14. Create RTCPeerConnection
- **Action**: RECEIVER creates their own instance of the `RTCPeerConnection`. This instance is necessary for generating an `answer` that our signaling server can send back to SENDER.

### 15. Decides on the Data for Sending and Receiving
- **Action**: RECEIVER must also decide what data it wishes to receive (in this case a file which will be done via a data channel)
  - **Important ‚ùó**: In a WebRTC connection, each peer can independently decide what types of data it wants to send and receive.

### 16. Add data types to RTCPeerConnection
- **Action**: RECEIVER registers a listener for the data channel (or adds media tracks if you're using video/audio calls) to its `RTCPeerConnection`.
- **Purpose**: This action associates RECEIVERS media data with the `RTCPeerConnection`.

### 17. Set Remote Description
- **Action**: After receiving the offer, RECEIVER can set the remote description via the `RTCPeerConnection.setRemoteDescription()` method.
- **Details**:
  - The `setRemoteDescription()` method informs the WebRTC connection (managed by the `RTCPeerConnection` interface) about the configuration proposed by the other peer (in this case, the file SENDER)
  - Without this information, RECEIVER would not know the data type proposed by SENDER

### 18. RECEIVER Creates an Answer
- **Action**: RECEIVER creates an answer object, using `createAnswer()`.
- **Details**:
  - The answer is an object of type `RTCSessionDescription`, which contains two parts:
    - **SDP**: Contains information about the data it will allow to be received.
    - **Type**: Designated as "answer," indicating that this description responds to an offer.

### 19. Set Local Description
- **Action**: RECEIVER assigns the generated answer to the `RTCPeerConnection` using the `setLocalDescription()` method, indicating that it is preparing a local answer.

### 20. GATHER ICE Candidates
- **Note**: When `setLocalDescription()` is executed by RECEIVER, ICE candidates will be automatically generated and returned to RECEIVER asynchronously. 

### 21. RECEIVE ICE Candidates
- **Action**: When ICE candidates are received, we need to store them in a buffer, or add them to the RECEIVERS pc object via the `addIceCandidate()` method. 

### 22. RECEIVER Sends "Answer" to signaling Server
- **Action**: RECEIVER sends the answer (of type `RTCSessionDescription`) to the signaling server.
- **Details**:
  - Our signaling server must then relay this answer back to SENDER.

### 23. RECEIVER Sends ICE Candidates to Signaling Server
- **Action**: Once ICE candidates become available, RECEIVER sends them to signaling server.
- **Details**:
  - The signaling server will relay these ICE candidates (routes) to SENDER.
  - Each ICE candidate will be associated with RECEIVER.

## PHASE 4: üì∂üì∂üì∂ Signaling Server
### 24. Signaling Server sends Answer (and ice candidates) to SENDER

## PHASE 5: üôç‚Äç‚ôÇÔ∏è SENDER Receives Answer

### 25. SENDER of the file receives the answer and ice candidates
- **Action**: SENDER receives an answer and ICE Candidates from the signaling server.

### 26. SENDER Sets Remote Description
- **Action**: SENDER has to now register the WebRTC "answer" from RECEIVER with its own instance of `RTCPeerConnection` by calling `setRemoteDescription()`.

## Final Comments

### Listening for ICE Candidates
- **Note**:
  - After each peer has successfully exchanged `RTCSessionDescription` control messages, they must wait for the arrival of ICE candidates.
  - The sending of the file cannot begin until both peers have received relevant ICE candidates from each other
  - For the iceconnectionstatechange to be in the "connected" state, the local and remote session descriptions needs to be fully completed
  - For the SENDER to send a file over the data channel, the 'onopen' event needs to fire first. 
  - BOTTOM LINE: Once both peers have exchanged ICE candidates, they can establish a fully functional WebRTC connection and begin sending/receiving data in compliance with their `RTCPeerConnection`.

### ONE LAST THING
- **SMILE**:
  - At this point, both peers have completed all necessary setup steps, including exchanging offers, answers, and ICE candidates.
  - A successful WebRTC connection has been established, enabling real-time communication between two peers! Files can now be sent and received. 
  - CELEBRATE ü•§